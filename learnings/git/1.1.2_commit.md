[Blob]{SHA-1 hash,content of file}
[Blob] ⇔ {Content + Header}


[Tree]{SHA-1 hash,list of pointer,file mode,object type(blob,tree),filename,nested directory subject}
[Tree] ⊂ {[*Pointer₁], [*Pointer₂], ...}
*Pointer ⇔ {Mode, Type, SHA-1, Name}
[❖Tree {SHA-1}] ⊂ {[Blob], [Sub-Tree]...}

[commit]{top level directory,metadata-author,committer(each with name,email,timestamp),commit message,parent}
[*Commit] ⊂ {*Tree-Pointer, [*Parent-Pointers], {Metadata}}


[Blob,tree,commit]{40-character SHA-1 hash( the object's content and its header)-[size]\0[content],immutable, change in content will change its hash result in new object}

[[Git Object]] ⇔ {Immutable Content} 


[commit]{Sha1 hash, parent - 0,1,2}
[*Commit] ⊂ {→ *Tree ⊂ {→ *Blob, ...}, ↔ *Parent, {Meta}}

{ Commit Graph}-{parent-child pointers}
[Commit Graph] ⇔ (*Commit₁ ↔ *Commit₂ ↔ ...) 

[*Commit {SHA-1}] ↔ [Parent *Commit] & → [❖Tree {SHA-1}] ⊂ {[Blob], [Sub-Tree]...} i

[*Commit {SHA-1}] ↔ [Parent *Commit]
[*Commit {SHA-1}] → [❖Tree {SHA-1}]

git add plan.txt
git commit -m "Initial campaign plan"

 [*Commit] ⊂ {→ *Tree ⊂ {→ *Blob, ...}, ↔ *Parent, {Meta}}



(branch @ [Current Commit]) ⇒ [New Pointer]
(branch) ⇒ [New Pointer File @ .git/refs/heads/]
git branch scout-mission

git log --oneline --decorate --graph

(checkout) ⇒ [HEAD] ↔ [scout-mission]
git checkout scout-mission
(checkout 'branch') ⇒ [HEAD File] {Content Change}



([string]"Hex Bolt...") --(hash-object)--> [Blob {SHA-1}]
echo "Hex Bolt M8x1.25" | git hash-object -w --stdin


(cat-file-p)@[blob hash]--->(see the blob content)
({SHA-1}) --(cat-file-p)--> (Perceive [Blob]'s {Content})
git cat-file -p YOUR_BLOB_HASH


add---> [index]{staged,tree}
([File {Modified}] @ Working Dir) → (add) → [Index {Updated Entry}]

adding new entry to tree to point the blob
(git update-index @)({mode}, {type}, {SHA-1}, {name})--> changes[index]

[Index] <-- (update-index)-- ({mode}, {type}, {SHA-1}, {name})


git update-index --add --cacheinfo 100644 YOUR_BLOB_HASH bolt.txt

(commit)
([Staged Changes]) --(commit)--> [*New Commit] ↔ [Parent Commit]

(add) ⇒ (write-tree) ⇒ (commit-tree)


create new tree from current tree

(git write-tree)@[tree]----->nes Tree{new sha1}
([Index]) --(write-tree)--> [Tree {SHA-1}]
git write-tree


(cat-file-p)@[tree hash]--->(see the tree pointers-list of pointers with mode, type, hash, and filename)
git cat-file -p YOUR_TREE_HASH


tree object -----> commit object 

([Tree]) --(commit-tree)--> [Commit {SHA-1}]
echo "Initial Design EN-42 v1.0" | git commit-tree YOUR_TREE_HASH


(cat-file-p)@[commit hash]--->(see the commit points to tree top level directory,metadata-author,committer(each with name,email,timestamp),commit message,parent)



git cat-file -p YOUR_COMMIT_HASH

([Staged Changes]) --(commit)--> [*New Commit] ↔ [Parent Commit]

 (add) ⇒ (write-tree) ⇒ (commit-tree)

git commit

([Staged Changes]) --(commit)--> [*New Commit] ↔ [Parent Commit]


(log) ⇒ (see @ [.git Repository]) → {Knowledge of Commit Graph(hash,commit message)}

git log --oneline --graph

conent change - new commit - new hash
what happens to old hash


[*Commit {SHA-1}] ↔ [Parent *Commit] & → [❖Tree {SHA-1}] ⊂ {[Blob], [Sub-Tree]...}


([Working Dir Changes]) → (commit) ⇒ [*New Commit] {points to} → [*Old Commit]

[main] → [*Commit-C1]
[main] → [*Commit-C2] ↔ [*Commit-C1]